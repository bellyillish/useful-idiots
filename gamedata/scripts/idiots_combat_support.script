local WP     = world_property
local UTIL   = require "illish.util"
local VEC    = require "illish.vector"
local POS    = require "illish.pos"
local NPC    = require "illish.npc"
local COMBAT = require "illish.combat"

EVAL_FF    = rx_ff.evaid
EVAL_FACER = xrs_facer.evid_facer
EVAL_ENEMY = stalker_ids.property_enemy
EVAL_LOGIC = xr_evaluators_id.state_mgr + 4
EVAL_ID    = stalker_ids.property_script  + 3180
ACTION_ID  = xr_actions_id.chugai_actions + 180


-- EVALUATOR --
  class "evaluator_combat_type" (property_evaluator)


  function evaluator_combat_type:__init(name, storage, type) super(nil, name)
    self.st   = storage
    self.type = type
  end


  function evaluator_combat_type:evaluate()
    local npc  = self.object
    return db.storage[npc:id()].script_combat_type == self.type
  end
--


-- ACTION METHODS --
  class "action_combat_support" (action_base)


  function action_combat_support:__init(name, storage) super(nil, name)
    self.st = storage
  end


  function action_combat_support:initialize()
    action_base.initialize(self)

    self.npc_on_hit_callback  = COMBAT.combatHitCallback
    self.npc_on_hear_callback = COMBAT.combatHearCallback

    RegisterScriptCallback("npc_on_hit_callback",  self)
    RegisterScriptCallback("npc_on_hear_callback", self)

    self:initConfig()
    self:initEnemy()
    self:initState()
    self:updateEnemy()
    self:updateState()
  end


  function action_combat_support:execute()
    action_base.execute(self)

    self:updateEnemy()
    self:updateState()

    local config = self.st.config
    local state  = self.st.state
    local npc    = self.object

    if state.action == "dodge"
      then self:dodge()
    elseif state.action == "movePoint"
      then self:movePoint()
    elseif state.action == "ffstrafe"
      then self:ffstrafe()
    elseif state.action == "push"
      then self:push()
    elseif state.action == "attack"
      then self:attack()
    elseif state.action == "idle"
      then state.vid = npc:level_vertex_id()
    end

    if not POS.isValidLVID(npc, state.vid) then
      state.vid     = npc:level_vertex_id()
      state.expires = time_plus(config.vidRetry)
    end

    state.reached = state.vid == npc:level_vertex_id()
    POS.setLVID(npc, state.vid)

    local move = COMBAT.getCombatMoveState(self)
    local look = COMBAT.getCombatLookState(self)

    state_mgr.set_state(npc, move, nil, nil, look, {fast_set = true})
  end


  function action_combat_support:finalize()
    action_base.finalize(self)

    UnregisterScriptCallback("npc_on_hit_callback",  self)
    UnregisterScriptCallback("npc_on_hear_callback", self)
  end
--


-- STATE --
  function action_combat_support:initConfig()
    local st = self.st

    st.config = {
      alwaysSee      = 2,
      moveDist       = 8,
      mutantDist     = 12,
      vidRetry       = 1000,
      useTeamSight   = true,
      maxDist        = {8, 16, 24},
      recoverHealth  = {0.32, 0.48},
      spottedTimeout = {800,  1200},
      lookTimeout    = {2500, 5000},
      moveDelay      = {2800, 4800},
      ffDelay        = {1200, 1600},
    }
  end


  function action_combat_support:initEnemy()
    local config = self.st.config
    local npc    = self.object
    local st     = self.st

    self.enemySpace = POS.assessSpace

    st.enemy = {
      id           = nil,
      pos          = nil,
      dist         = nil,
      dir          = nil,
      spottedUntil = nil,
      spotted      = true,
      seen         = false,
      wounded      = false,
      mutant       = false,
    }
  end


  function action_combat_support:updateEnemy()
    self.st.lastEnemy = dup_table(self.st.enemy)

    local config = self.st.config
    local enemy  = self.st.enemy
    local npc    = self.object

    local be = npc:best_enemy()
    if not be then
      return
    end

    if enemy.id ~= be:id() then
      enemy.spotted = true
    end

    enemy.seen   = npc:see(be) or COMBAT.hasLineOfSight(npc, be)
    enemy.mutant = IsMonster(be)
    enemy.id     = be:id()

    local reset = false
    local pos   = false

    if enemy.seen or enemy.spotted then
      reset = true
      pos   = true

    elseif distance_between(be, npc) <= config.alwaysSee then
      reset = true
      pos   = true

    elseif config.useTeamSight and COMBAT.teamSeesEnemy(npc, be) then
      reset = true
      pos   = true

    elseif not time_expired(enemy.spottedUntil) then
      pos = true
    end

    if pos then
      enemy.pos     = utils_obj.safe_bone_pos(be, "bip01_head")
      enemy.wounded = IsWounded(be)
    end

    if reset then
      enemy.spottedUntil = time_plus_rand(config.spottedTimeout)
    end

    enemy.dir  = vec_dir(utils_obj.safe_bone_pos(npc, "bip01_r_finger02"),  enemy.pos)
    enemy.dist = vec_dist(npc:position(), enemy.pos)

    enemy.spotted = false
  end


  function action_combat_support:initState()
    local config = self.st.config
    local st     = self.st

    self.isReloading      = NPC.isReloading
    self.assessCover      = POS.assessCover
    self.nearbyGrenades   = POS.nearbyGrenades
    self.getWeaponType    = NPC.getWeaponType
    self.getActorMovement = COMBAT.getActorMovement

    st.state = {
      action      = nil,
      vid         = nil,
      expires     = nil,
      grenades    = nil,
      weapon      = nil,
      cover       = nil,
      coverOrder  = nil,
      actorPos    = nil,
      maxDist     = nil,
      keepType    = nil,
      moveDist    = nil,
      ffDelay     = nil,
      reached     = false,
      reloading   = false,
      recovering  = false,
      dontShoot   = false,
    }
  end


  function action_combat_support:updateState()
    self.st.lastState = dup_table(self.st.state)

    local lastState = self.st.lastState
    local config    = self.st.config
    local state     = self.st.state
    local enemy     = self.st.enemy
    local npc       = self.object

    state.moveDist = self:getActorMovement()

    if not state.actorPos or state.moveDist >= config.moveDist then
      state.actorPos = db.actor:position()
    end

    state.keepType  = NPC.getActiveState(npc, "distance")
    state.grenades  = self.nearbyGrenades(npc:position(), config.dodgeDist)
    state.cover     = self.assessCover(npc:position(), enemy.pos)
    state.dontShoot = db.storage[npc:id()].rx_dont_shoot
    state.weapon    = self.getWeaponType(npc)
    state.reloading = self.isReloading(npc)

    state.maxDist = nil
      or state.keepType == "near" and config.maxDist[1]
      or state.keepType == "far"  and config.maxDist[3]
      or config.maxDist[2]

    state.recovering = npc.health <= config.recoverHealth[1]
      or lastState.recovering and npc.health <= config.recoverHealth[2]

    state.coverOrder = (state.recovering or state.reloading)
      and "peek"
      or  "shoot"

    if state.dontShoot then
      state.ffTimeout = time_plus(500)
      if state.reached and not state.ffDelay then
        state.ffDelay = time_plus_rand(config.ffDelay)
      end
    end

    if state.grenades then
      state.action = "dodge"

    elseif self.st.movePoint then
      state.action = "movePoint"

    elseif time_expired(state.ffDelay) and not time_expired(state.ffTimeout) then
      state.action = "ffstrafe"

    elseif enemy.wounded and not enemy.mutant and enemy.dist <= state.maxDist then
      state.action = "push"

    else
      state.action = "attack"
    end

    if lastState.action ~= state.action then
      if (lastState.action == "ffstrafe" or lastState.action == "movePoint") and state.action ~= "dodge" then
        state.vid = npc:level_vertex_id()
        state.expires = nil
      else
        state.expires = 0
      end
    end

    if time_expired(state.expires) then
      state.expires = nil
      state.vid     = nil
    end

    state.reached = state.vid == npc:level_vertex_id()

    if state.reached then
      self.st.moveState = nil
    end
  end
--


-- ACTIONS --
  function action_combat_support:dodge()
    local config = self.st.config
    local state  = self.st.state
    local npc    = self.object

    if state.vid then
      local dir = vec_dir(npc:position(), lvpos(state.vid))
      if vec_dot(dir, state.grenades.avgDir) > 0 then
        state.vid, state.expires = nil, nil
      end
    end

    if not state.vid then
      local dist = UTIL.random(10, 14, 1)
      local rot  = 180 + UTIL.randomRange(45)
      local dir  = vec_rot(state.grenades.avgDir, rot)
      local pos  = vec_offset(npc:position(), dir, dist)

      state.vid = POS.bestOutsideValidLVID(npc, npc:position(), pos)
    end
  end


  function action_combat_support:movePoint()
    local state = self.st.state

    if state.reached then
      self.st.movePoint = nil
    end

    if not state.vid then
      state.vid = self.st.movePoint
    end
  end


  function action_combat_support:ffstrafe()
    local config = self.st.config
    local state  = self.st.state
    local enemy  = self.st.enemy
    local npc    = self.object

    if state.reached and not state.expires then
      state.expires = time_plus_rand(config.ffDelay)
    end

    if not state.vid then
      state.vid = POS.getStrafePos(npc, {enemyPos = enemy.pos})
    end
  end


  function action_combat_support:push()
    local state = self.st.state
    local enemy = self.st.enemy
    local npc   = self.object

    if state.reached and not state.expires then
      state.expires = time_plus_rand(2500, 4000)
    end

    if state.reached and time_expired(state.expires) then
      enemy.wounded = false
    end

    if not state.vid then
      local dist = UTIL.random(2, 4, 1)
      local dir  = vec_rot_range(enemy.dir, 180)
      local pos  = vec_offset(enemy.pos, dir, dist)

      state.vid = POS.bestOutsideUnclaimedLVID(npc, npc:position(), pos)
    end
  end


  function action_combat_support:attack()
    local lastState = self.st.lastState
    local config    = self.st.config
    local enemy     = self.st.enemy
    local state     = self.st.state
    local npc       = self.object

    if state.moveDist > config.moveDist then
      state.vid, state.expires = nil, nil

    elseif state.reached and enemy.mutant and enemy.dist < config.mutantDist then
      state.vid, state.expires = nil, nil

    elseif state.keepType ~= lastState.keepType then
      state.vid, state.expires = nil, nil

    elseif state.reached and state.reloading and state.cover < 3 then
      state.vid, state.expires = nil, nil

    elseif state.reached and not state.expires and (state.cover < 2 or state.cover > 4) then
      state.expires = time_plus_rand(config.moveDelay)
    end

    if not state.vid then
      local findFn = state.keepType == "near" and POS.assessSpace(state.actorPos) ~= "open"
        and POS.bestInsideUnclaimedLVID
        or  POS.bestOutsideUnclaimedLVID

      local points = VEC.pointsAlongAxis({
        direction  = vec_dir(enemy.pos, state.actorPos),
        radius     = state.maxDist,
        position   = state.actorPos,
        arcAngle   = 225,
        rows       = 3,
        spacing    = 2,
        rowSpacing = 3,
      })

      local best = POS.pickByBestCover(npc, points, {
        order    = COMBAT.COVER_ORDER[state.coverOrder],
        enemyPos = enemy.pos,
        findFn   = findFn,
        findFrom = state.actorPos,
      })

      if best then
        state.vid = best.vid
      end
    end
  end
--


-- BINDER --
  function add_to_binder(npc, ini, storage, planner, temp)
    planner:add_evaluator(EVAL_ID,
      evaluator_combat_type("combat_support", storage, "support")
    )

    local action = action_combat_support("combat_support", storage)

    if action then
      action:add_precondition(WP(EVAL_ENEMY, true))
      action:add_precondition(WP(EVAL_ID, true))
      action:add_precondition(WP(EVAL_FACER, false))

      action:add_effect(WP(EVAL_LOGIC, false))
      action:add_effect(WP(EVAL_ENEMY, false))
      action:add_effect(WP(EVAL_ID, false))

      planner:add_action(ACTION_ID, action)

      if (schemes.rx_ff) then
        local ffAction = planner:action(rx_ff.evaid)

        if ffAction then
          ffAction:add_precondition(WP(EVAL_ID, false))
        end
      end
    end
  end
--
