local WP      = world_property
local CONFIG  = a_idiots_config
local ASSAULT = idiots_combat_assault
local SUPPORT = idiots_combat_support
local SNIPE   = idiots_combat_snipe
local GUARD   = idiots_combat_guard
local TABLE   = require "illish.table"
local UTIL    = require "illish.util"
local VEC     = require "illish.vector"
local POS     = require "illish.pos"
local WPN     = require "illish.weapon"
local NPC     = require "illish.npc"
local BEH     = require "illish.beh"
local COMBAT  = require "illish.combat"

ACTION_BEH  = axr_beh.beh_actid
EVAL_GATHER = xr_gather_items.evaid
EVAL_CORPSE = xr_evaluators_id.corpse_exist
EVAL_ITEMS  = stalker_ids.property_items
EVAL_HEAL   = xr_evaluators_id.wounded_exist


LOOT_SHARED_ITEMS = {}
LOOT_SHARING_NPCS = {}


-- UTILS_OBJ --
  BONE_ALIASES = {
    spine = {"spine", "spine_1", "bip01_spine", "bip01_spine1"},
    head  = {"head", "head_boss", "bip01_head"},
  }

  -- fix errors from inconsistent head and spine bone IDs in monsters
  function utils_obj.safe_bone_pos(obj, bone)
    if obj:get_bone_id(bone) ~= 65535 then
      return obj:bone_position(bone)
    end

    for match, aliases in pairs(BONE_ALIASES) do
      if bone:find(match) then
        for i, alias in ipairs(aliases) do
          if obj:get_bone_id(alias) ~= 65535 then
            return obj:bone_position(alias)
          end
        end
      end
    end

    return vec(obj:position()):add(0, 0.5, 0)
  end

  --[[ TODO
    function utils_obj.try_go_aside_object(npc,friend,pos,old_vid)
      if not (friend) then
        return
      end

      local mypos = npc:position()

      if (mypos:distance_to_sqr(friend:position()) < 3) then
        return
      end

      local _dir = vec_sub(mypos,pos)
      local dir = {}
      dir[1] = vector_rotate_y(vec_set(_dir),-90)
      dir[2] = vector_rotate_y(vec_set(_dir),90)
      local vid
      local radius = 12
      local base_point = friend:level_vertex_id()

      for i=1,2 do
        while (radius > 0) do
          vid = level.vertex_in_direction(base_point,dir[i],radius)
          if (utils_obj.validate(npc,vid)) then
            return utils_obj.lmove(npc,vid,old_vid)
          end
          radius = radius - 2
        end
      end
    end

    function utils_obj.try_to_strafe(npc,old_vid)
      local _dir = npc:direction()
      local dir = {}
      dir[1] = vector_rotate_y(vec_set(_dir),-90)
      dir[2] = vector_rotate_y(vec_set(_dir),90)
      local vid
      local radius = 10
      local base_point = npc:level_vertex_id()

      for i=1,2 do
        while (radius > 0) do
          vid = level.vertex_in_direction(base_point,dir[i],radius)
          if (utils_obj.validate(npc,vid)) then
            return utils_obj.lmove(npc,vid,old_vid)
          end
          radius = radius - 2
        end
      end
    end
  --]]
--


-- AXR_BEH --
  CUSTOM_TARGETS = {
    cover_spot   = BEH.setTargetCoverSpot,
    cover_actor  = BEH.setTargetFollowActor,
    follow_actor = BEH.setTargetFollowActor,
    look_around  = BEH.setTargetLookAround,
    relax_spot   = BEH.setTargetRelaxSpot,
  }

  local __init_custom_data   = axr_beh.init_custom_data
  local __initialize         = axr_beh.action_beh.initialize
  local __set_desired_target = axr_beh.action_beh.set_desired_target
  local __beh_move           = axr_beh.action_beh.beh_move
  local __beh_wait           = axr_beh.action_beh.beh_wait
  local __beh_cover          = axr_beh.action_beh.beh_cover
  local __beh_add_to_binder  = axr_beh.add_to_binder


  function axr_beh.init_custom_data(npc, ini, section, st, scheme)
    __init_custom_data(npc, ini, section, st, scheme)
    st.normal_desired_dist = ini:r_string_to_condlist(section, "normal_desired_dist", "4")
  end


  function axr_beh.action_beh:initialize()
    __initialize(self)

    local wmode = ui_mcm.get("idiots/options/autoReloadAll")
      and WPN.RELOAD_ALL
      or  WPN.RELOAD_ACTIVE

    NPC.setReloadModes(self.object, wmode, WPN.NOT_FULL)
  end


  function axr_beh.action_beh:set_desired_target()
    local npc = self.object
    local st  = self.st

    local target = xr_logic.pick_section_from_condlist(db.actor, npc, st.goto_target)

    if st.target == target and st.desired_target then
      st.savedTarget = dup_table(st.desired_target)
    else
      st.lookTimer   = nil
      st.lookPoint   = nil
      st.savedTarget = {}
    end

    st.lastTarget   = st.target
    st.lastKeepType = st.keepType

    local success  = __set_desired_target(self)
    local targetFn = CUSTOM_TARGETS[target]

    if success or not (NPC.isCompanion(npc) and targetFn) then
      return success
    end

    st.keepType = xr_logic.pick_section_from_condlist(db.actor, npc, st.keep_distance)

    return targetFn(self)
  end


  function axr_beh.action_beh:beh_move()
    local npc = self.object
    local st  = self.st

    if not (NPC.isCompanion(npc) and CUSTOM_TARGETS[st.target]) then
      return __beh_move(self)
    end

    if not st.setStateFn then
      st.setStateFn = UTIL.throttle(state_mgr.set_state, 100)
    end

    local move = BEH.getBehMoveState(self)
    local look = BEH.getBehLookState(self)

    st.setStateFn(npc, move, nil, nil, look, {fast_set = true})
  end


  function axr_beh.action_beh:beh_wait()
    local npc = self.object
    local st  = self.st

    if not (NPC.isCompanion(npc) and CUSTOM_TARGETS[st.target]) then
      return __beh_wait(self)
    end

    self:beh_move()
  end


  function axr_beh.action_beh:beh_cover()
    local npc = self.object
    local st  = self.st

    if not (NPC.isCompanion(npc) and CUSTOM_TARGETS[st.target]) then
      return __beh_cover(self)
    end

    self:beh_move()
  end


  function axr_beh.action_beh:beh_relax()
    local npc = self.object
    local st  = self.st

    if not (NPC.isCompanion(npc) and CUSTOM_TARGETS[st.target]) then
      return __beh_wait(self)
    end

    self:beh_move()
  end


  function axr_beh.add_to_binder(npc, ...)
    __beh_add_to_binder(npc, ...)

    local manager = npc:motivation_action_manager()
    local action  = manager:action(ACTION_BEH)

    if (schemes.gather_items) then
      action:add_precondition(WP(EVAL_GATHER, false))
    end
    if (schemes.corpse_detection) then
      action:add_precondition(WP(EVAL_CORPSE, false))
    end
    if (schemes.help_wounded) then
      action:add_precondition(WP(EVAL_HEAL, false))
    end

    action:add_precondition(WP(EVAL_ITEMS, false))
  end
--


-- XR_COMBAT --
  local __combat_evaluate  = xr_combat.evaluator_check_combat.evaluate
  local __add_to_binder    = xr_combat.add_to_binder

  -- prevent companions from getting stuck in legacy combat types
  function xr_combat.evaluator_check_combat:evaluate()
    xr_combat.set_combat_type(self.object, db.actor, self.st)
    return __combat_evaluate(self)
  end

  -- add custom combat types
  function xr_combat.add_to_binder(npc, ini, scheme, section, storage, temp)
    __add_to_binder(npc, ini, scheme, section, storage, temp)

    local manager = npc:motivation_action_manager()

    if manager and temp.section then
      ASSAULT.add_to_binder(npc, ini, storage, manager, temp)
      SUPPORT.add_to_binder(npc, ini, storage, manager, temp)
      SNIPE.add_to_binder(npc, ini, storage, manager, temp)
      GUARD.add_to_binder(npc, ini, storage, manager, temp)
    end
  end
--


-- XR_COMBAT_ZOMBIED --
  local __zombied_evaluate = xr_combat_zombied.evaluator_combat_zombied.evaluate

  -- allow companions to be in "zombied" combat
  function xr_combat_zombied.evaluator_combat_zombied:evaluate()
    local enabled = ui_mcm.get("idiots/options/zombiedCombat")
    local npc = self.object

    if enabled and NPC.isCompanion(npc) and NPC.getState(npc, "combat", "zombied") then
      return true
    end

    return __zombied_evaluate(self)
  end
--


-- XR_COMBAT_IGNORE --
  function getNightMultiplier(hr1, hr2, multiplier)
    if hr1 > hr2 or multiplier < 0 or multiplier > 1 then
      return 1
    end

    local hour  = level.get_time_hours()
    local mins  = level.get_time_minutes()
    local diff1 = math.abs(hr1 - 12)
    local diff2 = math.abs(hr2 - 12)

    local modifier = hour + (mins / 60)
          modifier = math.abs(modifier - 12)
          modifier = math.min(math.max(modifier, diff1), diff2)
          modifier = 1 - (modifier - diff1) / (hr2 - hr1) * (1 - multiplier)

    return math.min(1, math.max(1 - multiplier, modifier))
  end

  function getRainMultiplier(low, high, multiplier)
    local rain = level.rain_factor()

    if low > high or multiplier < 0 or multiplier > 1 or rain < 0 then
      return 1
    end

    local modifier = 1 - (rain / (high - low) - low) * (1 - multiplier)
          modifier = math.min(modifier, 1)
          modifier = math.max(modifier, 1 - multiplier)

    return math.min(1, math.max(1 - multiplier, modifier))
  end

  function getSurgeMultiplier(multiplier)
    return xr_conditions.surge_started()
      and multiplier
      or  1
  end

  function initCombatIgnoreConfig()
    local ini = ini_file("ai_tweaks\\xr_combat_ignore.ltx")

    this.config = {
      enemyRange      = ini:r_string_to_condlist("settings", "enemy_range", "nil"),
      enemyRangeMin   = ini:r_string_to_condlist("settings", "enemy_range_min", "nil"),
      enemyRangeSurge = ini:r_string_to_condlist("settings", "enemy_range_surge", "nil"),
      maxElevation    = ini:r_string_to_condlist("settings", "max_elevation", "nil"),
      memoryExpires   = ini:r_string_to_condlist("settings", "memory_expires", "nil"),
      nightMultiplier = ini:r_string_to_condlist("night_settings", "multiplier", "1"),
      rainMultiplier  = ini:r_string_to_condlist("rain_settings", "multiplier", "1"),
      surgeMultiplier = ini:r_string_to_condlist("surge_settings", "multiplier", "1"),
      safezoneExpires = ini:r_float_ex("settings", "safezone_expires", 0),
      nightMinHour    = ini:r_float_ex("night_settings", "min_hour", 18),
      nightMaxHour    = ini:r_float_ex("night_settings", "max_hour", 21),
      rainMinFactor   = ini:r_float_ex("rain_settings", "min_factor", 0),
      rainMaxFactor   = ini:r_float_ex("rain_settings", "max_factor", 1),
    }
  end

  function getCombatIgnoreConfig(enemy, npc)
    local cfg = dup_table(this.config)

    for k, v in pairs(cfg) do
      if type(v) == "table" then
        local value = xr_logic.pick_section_from_condlist(enemy, npc, v)
        cfg[k] = value and value ~= "nil" and tonumber(value) or nil
      end
    end

    cfg.nightMultiplier = getNightMultiplier(cfg.nightMinHour, cfg.nightMaxHour, cfg.nightMultiplier)
    cfg.rainMultiplier  = getRainMultiplier(cfg.rainMinFactor, cfg.rainMaxFactor, cfg.rainMultiplier)
    cfg.surgeMultiplier = getSurgeMultiplier(cfg.surgeMultiplier)

    if cfg.enemyRange and cfg.enemyRangeMin then
      cfg.enemyRange = math.max(cfg.enemyRangeMin, cfg.enemyRange * cfg.nightMultiplier * cfg.rainMultiplier * cfg.surgeMultiplier)
    end

    return cfg
  end

  function xr_combat_ignore.is_enemy(npc, enemy, noMemory)
    if device().precache_frame > 1 then
      return false
    end

    if not npc:alive() or not enemy:alive() then
      return false
    end

    if npc:clsid() == clsid.crow or enemy:clsid() == clsid.crow then
      return false
    end

    if DEV_DEBUG and xrs_debug_tools.debug_invis and enemy:id() == 0 then
      return false
    end

    -- callback override
    local flags = {
      override = false,
      result   = false
    }

    SendScriptCallback("on_enemy_eval", npc, enemy, flags)

    if flags.override then
      return flags.result
    end

    local pos1 = npc:position()
    local pos2 = enemy:position()
    local dist = pos2:distance_to(pos1)
    local fac1 = character_community(npc)
    local fac2 = character_community(enemy)
    local cfg  = getCombatIgnoreConfig(enemy, npc)

    -- ignore bribes
    if enemy:id() == 0 and xr_bribe.at_peace(fac1, fac2, dist * dist) then
      return false
    end

    -- ignore stale enemies
    if not noMemory and cfg.memoryExpires and time_global() > npc:memory_time(enemy) + cfg.memoryExpires then
      return false
    end

    -- respect combat_ignore_keep_when_attacked
    if enemy:id() == 0 and load_var(npc, "xr_combat_ignore_enabled") == false then
      db.storage[npc:id()].enemy_id = enemy:id()
      return true
    end

    -- ignore hostages
    if axr_task_manager.hostages_by_id[enemy:id()] then
      return false
    end

    -- ignore enemies when npc has far surge job
    if xr_conditions.surge_started() and cfg.enemyRangeSurge then
      local smart = xr_gulag.get_npc_smart(npc)
      local task = smart
         and smart.npc_info
         and smart.npc_info[npc:id()]
         and smart.npc_info[npc:id()].job
         and smart.npc_info[npc:id()].job.job_type_id == 2
         and smart.npc_info[npc:id()].job.alife_task

      if task and pos2:distance_to(task:position()) > cfg.enemyRangeSurge then
        return false
      end
    end

    -- ignore enemies in safe zones
    if enemy:id() ~= 0 and IsStalker(npc) and fac2 ~= "zombied" then
      local safeTimes    = xr_combat_ignore.safe_zone_npcs
      local ignoredZones = xr_combat_ignore.ignored_zone

      local se = alife():object(npc:id())
      local id = se and se.group_id ~= 65535 and se.group_id or npc:id()

      if safeTimes[id] then
        db.storage[npc:id()].heli_enemy_flag = nil

        if time_global() - safeTimes[id] < cfg.safezoneExpires then
          return false
        else
          safeTimes[id] = nil
        end

      elseif id then
        for i, zone in ipairs(ignoredZones) do
          if utils_obj.npc_in_zone(npc, zone) then
            safeTimes[id] = time_global()
            return false
          end
        end
      end

      local squad = get_object_squad(enemy)
      id = squad and squad.id or enemy:id()

      if safeTimes[id] then
        return false
      else
        for i, zone in ipairs(ignoredZones) do
          if utils_obj.npc_in_zone(enemy, zone) then
            safeTimes[id] = time_global()
            return false
          end
        end
      end
    end

    -- ignore underground vs. above-ground fights
    if cfg.maxElevation
      and math.abs(pos1.y - pos2.y) > cfg.maxElevation
      and not npc:see(enemy)
      and not enemy:see(npc)
    then
      return false
    end

    -- ignore based on distance
    if cfg.enemyRange and dist > cfg.enemyRange then
      return false
    end

    -- save enemy before overriding
    if npc:relation(enemy) >= game_object.enemy then
      db.storage[npc:id()].enemy_id = enemy:id()
    end

    -- ignore based on overrides
    if xr_combat_ignore.ignore_enemy_by_overrides(npc, enemy) then
      return false
    end

    return true
  end
--


-- XR_DANGER
  local __npc_on_hear_callback = xr_danger.npc_on_hear_callback

  -- fix incorrectly overwritten values (for Anomaly)
  xr_danger.bd_types[danger_object.entity_attacked] = "entity_attacked"
  xr_danger.bd_types[danger_object.bullet_ricochet] = "bullet_ricochet"
  xr_danger.bd_types[danger_object.attack_sound]	  = "attack_sound"

  -- add IsStalker() corpse check (for Anomaly)
  function xr_danger.get_danger_time(danger)
    if danger:type() ~= danger_object.entity_corpse then
      return danger:time()
    end

    local corpse = danger:object()
    return IsStalker(corpse) and corpse:death_time() or 0
  end

  -- add check (for Anomaly)
  function xr_danger.npc_on_hear_callback(npc, ...)
    if not xr_danger.has_danger(npc) then
      __npc_on_hear_callback(npc, ...)
    end
  end

  -- disable hit callback (for Anomaly)
  function xr_danger.npc_on_hit_callback()
    --noop
  end

  -- restructure and fix a few bugs in xr_danger
  function xr_danger.is_danger(npc, danger)
    if xr_wounded.is_heavy_wounded_by_id(npc:id()) then
      return false
    end

    if axr_task_manager.hostages_by_id[npc:id()] then
      return false
    end

    local dangerObject = danger:object()
    local dangerType   = danger:type()

    if dangerType == danger_object.grenade then
      if danger:dependent_object() and character_community(npc) ~= "zombied" then
        return xr_danger.danger_in_radius(npc, danger, dangerType)
      end

      return false
    end

    if xr_combat_ignore.npc_in_safe_zone(npc) then
      return false
    end

    if dangerType == danger_object.entity_corpse then
      if not (dangerObject and IsStalker(dangerObject) and character_community(dangerObject) == character_community(npc)) then
        return false
      end

      local corpse = db.storage[dangerObject:id()]

      if not (corpse and corpse.death_time and corpse.death_by_id) then
        return false
      end

      local killer = db.storage[corpse.death_by_id] and db.storage[corpse.death_by_id].object

      if not (killer and (IsMonster(killer) or IsStalker(killer)) and killer:alive() and npc:relation(killer) > 0 and character_community(killer) ~= character_community(npc)) then
        return false
      end

      if xr_combat_ignore.ignore_enemy_by_overrides(npc, killer) then
        return false
      end

      if game.get_game_time():diffSec(corpse.death_time) > 120000 then
        return false
      end

      return xr_danger.danger_in_radius(npc, danger, dangerType)
    end

    if danger:dependent_object() then
      dangerObject = danger:dependent_object()
    end

    if not (dangerObject and (IsMonster(dangerObject) or IsStalker(dangerObject)) and npc:relation(dangerObject) >= game_object.enemy) then
      return false
    end

    -- bypass combat ignore radius for attacked, entity_attacked, ricochet
    if danger:perceive_type() == danger_object.hit then
      return xr_danger.danger_in_radius(npc, danger, dangerType)
    end

    if xr_corpse_detection.is_under_corpse_detection(npc) or xr_help_wounded.is_under_help_wounded(npc) or xrs_kill_wounded.is_under_kill_wounded(npc) then
      return false
    end

    if not dangerObject:alive() or not xr_combat_ignore.is_enemy(npc, dangerObject, true) then
      return false
    end

    return xr_danger.danger_in_radius(npc, danger, dangerType)
  end
--


-- XR_WEAPON_JAM
  function xr_weapon_jam.npc_on_update(npc)
    local SETTINGS = xr_weapon_jam.SETTINGS
    local TRACKING = xr_weapon_jam.GUN_TRACKING

    if SETTINGS.enabled == "false" then
      return
    end

    if not npc:alive() or not npc:best_enemy() then
      return
    end

    local weapon = npc:active_item()
    if not IsWeapon(weapon) then
      return
    end

    if not TRACKING[weapon:id()] then
      TRACKING[weapon:id()] = {ammo_last_update = 0, rounds_since_jam = 0}
    end

    local ammo = WPN.getAmmoCount(weapon)
    local prevAmmo = TRACKING[weapon:id()].ammo_last_update
    TRACKING[weapon:id()].ammo_last_update = ammo.current

    if ammo.current == 0 or ammo.current >= prevAmmo then
      return
    end

    local totalSpent = TRACKING[weapon:id()].rounds_since_jam + prevAmmo - ammo.current
    TRACKING[weapon:id()].rounds_since_jam = totalSpent

    local rank = ranks.get_obj_rank_name(npc)
    local baseChance = SETTINGS["base_ch_".. rank]
    local maxChance  = SETTINGS["max_ch_" .. rank]

    local chance = math.min(UTIL.round(totalSpent * baseChance / ammo.total ^ SETTINGS.clip_size_factor, 2), maxChance)

    if UTIL.random(1, 100, 2) <= chance then
      weapon:unload_magazine()
      TRACKING[weapon:id()].ammo_last_update = 0
      TRACKING[weapon:id()].rounds_since_jam = 0
    end
  end
--


-- AXR_COMPANIONS --
  local __is_assigned_item = axr_companions.is_assigned_item

  -- sync with global state when joining
  function axr_companions.add_to_actor_squad(npc)
    axr_companions.non_task_companions[npc:id()] = true
    se_save_var(npc:id(), npc:name(), "companion", true)
    npc:inactualize_patrol_path()
    axr_companions.setup_companion_logic(npc, db.storage[npc:id()], false)

    -- reset other flags
    save_var(npc, "fight_from_point", nil)

    -- load companion states
    NPC.setStates(npc, NPC.GLOBAL_STATE)
  end

  -- don't teleport if flag is set in NPC.ACTIONS
  function axr_companions.companion_squad_can_teleport(squad)
    local sim = alife()
    local id  = squad:commander_id()
    local se  = sim:object(id)

    if se and se_load_var(se.id, se:name(), "companion_cannot_teleport") then
      return false
    end

    for ig, group in ipairs(NPC.ACTIONS) do
      for ia, action in ipairs(group.actions) do
        if action.teleport == false and sim:has_info(id, action.info) then
          return false
        end
      end
    end

    return true
  end

  -- disable anomaly companion wheel
  function axr_companions.on_key_release()
  end

  -- disable anomaly move to point
  function axr_companions.move_to_point()
  end

  -- show all or only gathered and looted items in inventory
  function axr_companions.is_assigned_item(npcID, itemID)
    local showAll = ui_mcm.get("idiots/options/showAllItems")

    if NPC.isCompanion(npcID) and (showAll or LOOT_SHARED_ITEMS[itemID]) then
      return true
    end

    return __is_assigned_item(npcID, itemID)
  end
--


-- XR_GATHER_ITEMS
  local __gather_evaluate   = xr_gather_items.eva_gather_itm.evaluate
  local __gather_initialize = xr_gather_items.act_gather_itm.initialize
  local __gather_finalize   = xr_gather_items.act_gather_itm.finalize
  local __gather_find_item  = xr_gather_items.eva_gather_itm.find_valid_item

  -- disable NPC gathering
  function xr_gather_items.eva_gather_itm:evaluate()
    local noGathering = ui_mcm.get("idiots/options/noNpcLooting")

    if noGathering and not NPC.isCompanion(self.object) then
      return false
    end

    return __gather_evaluate(self)
  end

  -- start tracking gathered items
  function xr_gather_items.act_gather_itm:initialize()
    if NPC.isCompanion(self.object) then
      LOOT_SHARING_NPCS[self.object:id()] = true
    end

    __gather_initialize(self)
  end

  -- stop tracking gathered items
  function xr_gather_items.act_gather_itm:finalize()
    LOOT_SHARING_NPCS[self.object:id()] = nil
    __gather_finalize(self)
  end

  -- enable/disable artifact gathering
  function xr_gather_items.eva_gather_itm:find_valid_item()
    if NPC.isCompanion(self.object) then
      if not self.st.ARTIFACTS_ORIGINAL then
        self.st.ARTIFACTS_ORIGINAL = self.st.gather_artefact_items_enabled
        self.st.ARTIFACTS_DISABLER = {{"false"}}
      end

      local artifactsEnabled = ui_mcm.get("idiots/options/artifacts")

      if not artifactsEnabled
        then self.st.gather_artefact_items_enabled = self.st.ARTIFACTS_DISABLER
        else self.st.gather_artefact_items_enabled = self.st.ARTIFACTS_ORIGINAL
      end
    end

    return __gather_find_item(self)
  end
--


-- XR_CORPSE_DETECTION --
  local __corpse_evaluate   = xr_corpse_detection.evaluator_corpse.evaluate
  local __corpse_initialize = xr_corpse_detection.action_search_corpse.initialize
  local __corpse_finalize   = xr_corpse_detection.action_search_corpse.finalize

  function xr_corpse_detection.evaluator_corpse:evaluate()
    local noGathering = ui_mcm.get("idiots/options/noNpcLooting")

    if noGathering and not NPC.isCompanion(self.object) then
      return false
    end

    return __corpse_evaluate(self)
  end

  -- start tracking looted items
  function xr_corpse_detection.action_search_corpse:initialize()
    if NPC.isCompanion(self.object) then
      LOOT_SHARING_NPCS[self.object:id()] = true
    end

    __corpse_initialize(self)
  end

  -- stop tracking looted items
  function xr_corpse_detection.action_search_corpse:finalize()
    LOOT_SHARING_NPCS[self.object:id()] = nil
    __corpse_finalize(self)
  end
--


-- XR_HELP_WOUNDED --
  local __help_wounded_evaluate = xr_help_wounded.evaluator_wounded_exist.evaluate

  -- add a condlist to axr_beh to help wounded
  function xr_help_wounded.evaluator_wounded_exist:evaluate()
    if NPC.isCompanion(self.object) then
      local npc = self.object
      local st  = self.a

      if not st.help_wounded_cond then
        st.help_wounded_cond = xr_logic.parse_condlist(npc, "beh", "help_wounded_enabled", st.help_wounded_enabled)
      end

      st.help_wounded_enabled = xr_logic.pick_section_from_condlist(db.actor, npc, st.help_wounded_cond) == "true"
    end

    return __help_wounded_evaluate(self)
  end
--


-- SR_LIGHT --
  local __check_light = sr_light.check_light

  function sr_light.check_light(npc)
    if not NPC.isCompanion(npc) then
      __check_light(npc)
      return
    end

    local state = NPC.getActiveState(npc, "light")
    local torch = npc:object("device_torch")

    if not (torch and state) then
      __check_light(npc)
      return
    end

    if state == "off" or state == "on" then
      torch:enable_attachable_item(state == "on")
      return
    end

    local mimicActor = ui_mcm.get("idiots/options/autoLight")

    if not (mimicActor and NPC.isFollower(npc)) then
      __check_light(npc)
      return
    end

    local actorTorch   = db.actor:item_in_slot(10)
    local actorEnabled = actorTorch and actorTorch:torch_enabled() or false

    torch:enable_attachable_item(actorEnabled)
  end
--


-- RX_FF --
  local __ff_eval = rx_ff.evaluator_dont_shoot.evaluate

  -- 1. grace period before strafing/moving
  -- 2. shorter strafing/moving time
  function rx_ff.evaluator_dont_shoot:evaluate()
    local npc = self.object
    local st  = self.st

    -- don't move at first
    if not time_expired(st.__wait_until) then
      self.st.vertex_id = npc:level_vertex_id()
    end

    -- shorten hold time
    if st.__hold_until and st.__hold_until > time_plus(500) then
      st.__hold_until = time_plus(500)
    end

    local eval = __ff_eval(self)

    -- custom combat handles friendly fire
    local combat = db.storage[npc:id()].script_combat_type
    if combat == "assault" or combat == "guard" or combat == "snipe" or combat == "support" then
      return false
    end

    if not eval then
      st.__wait_until = nil
    elseif not time_expired(st.__wait_until) then
      st.__wait_until = st.__wait_until or time_plus(1500)
    end

    return eval
  end

  -- make friend_dist smaller
  function rx_ff.evaluator_dont_shoot:check_in_los(ally, enemy, enemyPos)
    local npc = self.object
    local minDist = 0.8

    if not (ally and ally:alive() and npc:see(ally) and npc:relation(ally) < 2) then
      return false
    end

    local pos       = utils_obj.safe_bone_pos(npc, "bip01_r_finger02")
    local allyPos   = utils_obj.safe_bone_pos(ally, "bip01_spine")
    local enemyDist = pos:distance_to(enemyPos)
    local allyDist  = pos:distance_to(allyPos)

    if allyDist < minDist then
      return true
    end

    local enemyDir = vec_sub(enemyPos, pos):normalize()
    local allyDir  = vec_sub(allyPos, pos):normalize()
    local enemyVec = enemyDir:set_length(allyDist)
    local allyVec  = allyDir:set_length(allyDist)

    if allyVec:similar(enemyVec, 0) == 1 or allyVec:similar(enemyVec, 1) == 1 then
      return true
    end
  end
--


-- XR_CONDITIONS --
  function xr_conditions.follow_crouch(actor, npc)
    if not ui_mcm.get("idiots/options/autoSneak") then
      return false
    end
    return IsMoveState("mcCrouch") and NPC.isFollower(npc)
  end

  function xr_conditions.follow_prone(actor, npc)
    if not ui_mcm.get("idiots/options/autoProne") then
      return false
    end
    return IsMoveState("mcCrouch") and IsMoveState("mcAccel") and NPC.isFollower(npc)
  end

  function xr_conditions.follow_sprint(actor, npc)
    if not ui_mcm.get("idiots/options/autoSprint") then
      return false
    end
    return IsMoveState("mcSprint") and NPC.isFollower(npc)
  end

  function xr_conditions.enemy_monster(enemy, npc)
    return IsMonster(enemy) or character_community(enemy) == "zombied"
  end

  function xr_conditions.story_related(enemy, npc)
    if enemy:id() == 0 then
      return false
    end

    if get_object_story_id(npc:id()) or get_object_story_id(enemy:id()) then
      return true
    end

    local nsquad = get_object_squad(npc)
    local esquad = get_object_squad(enemy)

    if nsquad and get_object_story_id(nsquad.id) or esquad and get_object_story_id(esquad.id) then
      return true
    end

    return false
  end

  function xr_conditions.cordon_army_vs_stalker(enemy, npc)
    if alife():has_info(npc:id(), "npcx_is_companion") then
      return false
    end

    if enemy:id() == 0 or alife():has_info(enemy:id(), "npcx_is_companion") then
      return false
    end

    if level.name() ~= "l01_escape" then
      return false
    end

    local ncomm = character_community(npc)
    local ecomm = character_community(enemy)

    return ncomm == "army"    and ecomm == "stalker"
        or ncomm == "stalker" and ecomm == "army"
  end

  function xr_conditions.npc_companion(enemy, npc)
    return alife():has_info(npc:id(), "npcx_is_companion")
      and true
      or  false
  end

  function xr_conditions.is_gamma()
    return grok_gamma_manual_on_startup and true or false
  end
--


-- ANIMATIONS --
  -- fix prone animation
  state_lib.states.prone.movement = move.stand
  state_lib.states.prone_idle.movement = move.stand
  state_lib.states.prone_fire.movement = move.stand
  state_lib.states.prone_sniper_fire.movement = move.stand
  state_lib.states.prone_sniper_fire.direction = nil

  state_mgr_animation_list.animations.prone.prop.moving = nil
  state_mgr_animation_list.animations.prone_idle.prop.moving = nil
--


-- STATE_MGR --
  local __set_state = state_mgr.set_state

  -- 1. force {fast_set = true} on all companion animations because it seems to
  --    fix issues with them getting stuck or being unresponsive
  -- 2. swap hide with hide_na after "in" animation because it makes companions
  --    twitch oddly when idle
  -- 3. swap prone with prone_idle after "in" animation because otherwise
  --    companions get up with every direction change
  -- 4. validate look_position and look_dir because directions with very small
  --    or zero magnitudes can make NPCs/companions disappear
  function state_mgr.set_state(npc, state_name, callback, timeout, target, extra)
    if NPC.isCompanion(npc) then
      local st = db.storage[npc:id()]

      if state_name == "hide" then
        st.__idiots_prone_fix = nil
        if not st.__idiots_hide_fix then
          st.__idiots_hide_fix = time_plus(1000)
        elseif time_expired(st.__idiots_hide_fix) then
          state_name = "hide_na"
        end

      elseif state_name == "prone" then
        st.__idiots_hide_fix  = nil
        if not st.__idiots_prone_fix then
          st.__idiots_prone_fix = time_plus(1000)
        elseif time_expired(st.__idiots_prone_fix) then
          state_name = "prone_idle"
        end

      else
        st.__idiots_hide_fix  = nil
        st.__idiots_prone_fix = nil
      end

      extra = extra or {}
      extra.fast_set = extra.fast_set ~= false
    end

    if target then
      if target.look_position then
        local dir = VEC.direction(npc:position(), target.look_position)
        if UTIL.round(dir:magnitude()) ~= 1 then
          target.look_position = nil
        end
      end
      if target.look_dir then
        if UTIL.round(target.look_dir:magnitude()) ~= 1 then
          target.look_dir = nil
        end
      end
    end

    return __set_state(npc, state_name, callback, timeout, target, extra)
  end
--


-- COMPANION ANTI AWOL --
  -- prevent it from using this variable before it is defined
  if companion_anti_awol then
    companion_anti_awol.companion_retreat = {}
  end
--


-- CALLBACKS --
  -- prevent npcs from entering invalid "cover" combat type
  if schemes_ai_gamma and schemes_ai_gamma.scheme_cover then
    function schemes_ai_gamma.scheme_cover()
      return false
    end
  end

  -- "He is with me" replacement
  function onEvalEnemy(npc, enemy, flags)
    if npc:has_info("npcx_is_companion") and enemy:has_info("npcx_is_companion") then
      flags.override, flags.result = true, false

    elseif npc:has_info("npcx_is_companion") and enemy:relation(db.actor) < game_object.enemy then
      flags.override, flags.result = true, false

    elseif enemy:has_info("npcx_is_companion") and npc:relation(db.actor) < game_object.enemy then
      flags.override, flags.result = true, false
    end
  end

  if he_is_with_me and he_is_with_me.escorteval then
    he_is_with_me.escorteval = onEvalEnemy
  end

  -- danger state for companions
  function onEvalDanger(npc, flags)
    if not NPC.isCompanion(npc) then
      return
    end

    local danger = npc:best_danger()
    if not danger then
      return
    end

    if danger:type() == danger_object.grenade then
      return
    end

    local enemy = danger:dependent_object() or danger:object()

    if enemy and xr_combat_ignore.is_enemy(npc, enemy) then
      if danger:perceive_type() == danger_object.hit then
        return
      end

      local hitBy = db.storage[npc:id()].hitted_by
      if hitBy and enemy and hitBy == enemy:id() then
        return
      end

      NPC.lookAtPoint(npc, enemy:position())
    end

    flags.ret_value = false
  end

  -- switch weapons
  function onChooseWeapon(npc, wpn, flags)
    if not NPC.isCompanion(npc) then
      return
    end

    local selected = NPC.getActiveState(npc, "weapon")
    local wmode    = NPC.getReloadWeaponMode(npc)
    local weapons  = NPC.getGuns(npc)

    -- unloaded
    if wmode then
      local id = NPC.setReloadWeapon(npc)

      if id then
        flags.gun_id = id
        return
      end

      if wmode == WPN.RELOAD_ALL then
        for i, weapon in ipairs(weapons) do
          if WPN.isUnloaded(weapon) then
            flags.gun_id = weapon:id()
            return
          end
        end
      end
    end

    -- nothing to reload
    NPC.setReloadModes(npc, 0, 0)

    table.sort(weapons, function(w1, w2)
      -- selected in UI
      local t1 = WPN.getType(w1)
      local t2 = WPN.getType(w2)

      if t1 == "smg" then
        t1 = "rifle"
      end
      if t2 == "smg" then
        t2 = "rifle"
      end

      if t1 ~= t2 and t1 == selected then
        return true
      elseif t1 ~= t2 and t2 == selected then
        return false
      end

      -- repair kit type
      local kits = {"pistol", "shotgun", "rifle_5", "rifle_7"}
      local p1 = TABLE.keyof(kits, WPN.getRepairType(w1)) or 5
      local p2 = TABLE.keyof(kits, WPN.getRepairType(w2)) or 5

      if p1 > p2 then
        return true
      elseif p1 < p2 then
        return false
      end

      -- cost
      return WPN.getCost(w2) < WPN.getCost(w1)
    end)

    if weapons[1] then
      flags.gun_id = weapons[1]:id()
    end
  end

  -- track gathered/looted item
  function onTakeItem(npc, item)
    if NPC.isCompanion(npc) and LOOT_SHARING_NPCS[npc:id()] then
      LOOT_SHARED_ITEMS[item:id()] = true
    end
  end

  -- clear shared item once actor takes it
  function onActorTakeItem(item)
    LOOT_SHARED_ITEMS[item:id()] = nil
  end

  -- cleanup gathered/looted item
  function onEntityUnregister(entity)
    LOOT_SHARED_ITEMS[entity.id] = nil
  end

  -- reconfigure on MCM changes
  function reconfigureStates()
    -- legacy combat disabled
    local camperCombat   = ui_mcm.get("idiots/options/camperCombat")
    local monolithCombat = ui_mcm.get("idiots/options/monolithCombat")
    local zombiedCombat  = ui_mcm.get("idiots/options/zombiedCombat")

    local gstate = NPC.getActiveState(nil, "combat")

    if false
      or not camperCombat   and gstate == "camper"
      or not monolithCombat and gstate == "monolith"
      or not zombiedCombat  and gstate == "zombied"
    then
      NPC.setState(nil, "combat", "default", true)
    end

    for i, npc in ipairs(NPC.getCompanions()) do
      local state = NPC.getActiveState(npc, "combat")

      if false
        or not camperCombat   and state == "camper"
        or not monolithCombat and state == "monolith"
        or not zombiedCombat  and state == "zombied"
      then
        NPC.setState(npc, "combat", "default", true)
      end
    end

    -- artifact gathering disabled
    if not ui_mcm.get("idiots/options/artifacts") then
      NPC.setState(nil, "jobs", "loot_artifacts", false)

      for i, npc in ipairs(NPC.getCompanions()) do
        NPC.setState(npc, "jobs", "loot_artifacts", false)
      end
    end
  end

  -- prep storage
  function initStorage()
    local mdata = alife_storage_manager.get_state()

    if not mdata[CONFIG.DATA_KEY] then
      mdata[CONFIG.DATA_KEY] = {}
    end

    return mdata[CONFIG.DATA_KEY]
  end

  -- load data
  function onLoadState(mdata)
    local data = initStorage()

    -- purge old mod keys
    for i, k in ipairs(CONFIG.DATA_STALE_KEYS) do
      mdata[k] = nil
    end

    -- migrate old jobs keys
    if data.IDIOTS_SHARED_ITEMS then
      data.sharedItems = data.IDIOTS_SHARED_ITEMS
    end
    if data.IDIOTS_SHARING_NPCS then
      data.sharingNPCs = data.IDIOTS_SHARING_NPCS
    end

    data.IDIOTS_SHARED_ITEMS = nil
    data.IDIOTS_SHARING_NPCS = nil

    -- check version
    if data.VER ~= CONFIG.DATA_VER then
      data.VER = CONFIG.DATA_VER
      data.companionStates = nil
      data.globalState = nil
    end

    -- load jobs data
    if data.sharedItems then
      LOOT_SHARED_ITEMS = data.sharedItems
    end
    if data.sharingNPCs then
      LOOT_SHARING_NPCS = data.sharingNPCs
    end

    -- load global state
    if data.globalState then
      NPC.GLOBAL_STATE = TABLE.merge(NPC.GLOBAL_STATE, data.globalState)
    else
      NPC.GLOBAL_STATE = dup_table(NPC.DEFAULT_STATE)
    end

    -- legacy combat disabled
    local camperCombat   = ui_mcm.get("idiots/options/camperCombat")
    local monolithCombat = ui_mcm.get("idiots/options/monolithCombat")
    local zombiedCombat  = ui_mcm.get("idiots/options/zombiedCombat")

    local gstate = NPC.getActiveState(nil, "combat")

    if false
      or not camperCombat   and gstate == "camper"
      or not monolithCombat and gstate == "monolith"
      or not zombiedCombat  and gstate == "zombied"
    then
      NPC.setState(nil, "combat", "default", true)
    end

    -- artifact gathering disabled
    if not ui_mcm.get("idiots/options/artifacts") then
      NPC.setState(nil, "jobs", "loot_artifacts", false)
    end
  end

  -- save data
  function onSaveState()
    local data = initStorage()

    data.globalState = NPC.GLOBAL_STATE
    data.sharedItems = LOOT_SHARED_ITEMS
    data.sharingNPCs = LOOT_SHARING_NPCS

    data.companionStates = {}

    for i, npc in ipairs(NPC.getCompanions()) do
      data.companionStates[npc:id()] = NPC.getAllStates(npc)
    end
  end

  -- load npc states
  function onNpcSpawn(npc)
    if not NPC.isCompanion(npc) then
      return
    end

    local data = initStorage()

    -- reset other flags
    save_var(npc, "fight_from_point", nil)

    -- load companion states
    if data.companionStates and data.companionStates[npc:id()] then
      NPC.setStates(npc, data.companionStates[npc:id()])
    else
      NPC.setStates(npc, NPC.GLOBAL_STATE)
    end

    -- legacy combat disabled
    local camperCombat   = ui_mcm.get("idiots/options/camperCombat")
    local monolithCombat = ui_mcm.get("idiots/options/monolithCombat")
    local zombiedCombat  = ui_mcm.get("idiots/options/zombiedCombat")

    local state = NPC.getActiveState(npc, "combat")

    if false
      or not camperCombat   and state == "camper"
      or not monolithCombat and state == "monolith"
      or not zombiedCombat  and state == "zombied"
    then
      NPC.setState(npc, "combat", "default", true)
    end

    -- artifact gathering disabled
    if not ui_mcm.get("idiots/options/artifacts") then
      NPC.setState(npc, "jobs", "loot_artifacts", false)
    end
  end

  -- clear saved data
  function onFirstUpdate()
    local data = initStorage()

    data.companionStates = nil
    data.globalState     = nil
    data.sharingNPCs     = nil
    data.sharedItems     = nil
  end
--


-- ON_GAME_START
  function on_game_start()
    initCombatIgnoreConfig()

    RegisterScriptCallback("load_state", onLoadState)
    RegisterScriptCallback("save_state", onSaveState)
    RegisterScriptCallback("npc_on_net_spawn", onNpcSpawn)
    RegisterScriptCallback("actor_on_first_update", onFirstUpdate)
    RegisterScriptCallback("server_entity_on_unregister", onEntityUnregister)
    RegisterScriptCallback("mcm_option_change", reconfigureStates)
    RegisterScriptCallback("npc_on_choose_weapon", onChooseWeapon)
    RegisterScriptCallback("npc_on_item_take", onTakeItem)
    RegisterScriptCallback("actor_on_item_take", onActorTakeItem)
    RegisterScriptCallback("npc_on_eval_danger", onEvalDanger)

    if not (he_is_with_me and he_is_with_me.escorteval) then
      RegisterScriptCallback("on_enemy_eval", onEvalEnemy)
    end
  end
--
